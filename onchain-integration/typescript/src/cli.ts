import {
  AptosParserRepo,
  getTypeTagFullname,
  StructTag,
  parseTypeTagOrThrow,
  u8,
  u64,
  u128,
  print,
  strToU8,
  u8str,
  DummyCache,
  ActualStringClass,
  sendPayloadTx,
  sendPayloadTxAndLog,
  getSimulationKeys,
} from "@manahippo/move-to-ts";
import { AptosAccount, AptosClient, HexString, Types } from "aptos";
import { Command } from "commander";
import { getProjectRepo } from "./";
import * as fs from "fs";
import * as yaml from "yaml";
import * as Coin_list from "./coin_list";
import * as Econia from "./econia";
import * as Hippo_aggregator from "./hippo_aggregator";
import * as Sample from "./sample";
import { TradeAggregator } from "@manahippo/hippo-sdk";
import { buildPayload_swap_and_transfer } from "./sample/sample";

export const readConfig = (program: Command) => {
  const { config, profile } = program.opts();
  const ymlContent = fs.readFileSync(config, { encoding: "utf-8" });
  const result = yaml.parse(ymlContent);
  //console.log(result);
  if (!result.profiles) {
    throw new Error("Expect a profiles to be present in yaml config");
  }
  if (!result.profiles[profile]) {
    throw new Error(`Expect a ${profile} profile to be present in yaml config`);
  }
  const url = result.profiles[profile].rest_url;
  const privateKeyStr = result.profiles[profile].private_key;
  if (!url) {
    throw new Error(`Expect rest_url to be present in ${profile} profile`);
  }
  if (!privateKeyStr) {
    throw new Error(`Expect private_key to be present in ${profile} profile`);
  }
  const privateKey = new HexString(privateKeyStr);
  const client = new AptosClient(result.profiles[profile].rest_url);
  const account = new AptosAccount(privateKey.toUint8Array());
  console.log(`Using address ${account.address().hex()}`);
  return { client, account };
};

const program = new Command();

program
  .name("yarn cli")
  .description("Move TS CLI generated by move-to-ts")
  .requiredOption(
    "-c, --config <path>",
    'path to your aptos config.yml (generated with "aptos init")'
  )
  .option("-p, --profile <PROFILE>", "aptos config profile to use", "default");

const coin_list_add_approver_to_list = async (
  approver: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const approver_ = new HexString(approver);
  const max_gas_ = parseInt(max_gas);
  const payload =
    Coin_list.Coin_list.buildPayload_add_approver_to_list(approver_);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:add-approver-to-list")
  .description("")
  .argument("<approver>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_add_approver_to_list);

const coin_list_add_approver_to_registry = async (
  approver: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const approver_ = new HexString(approver);
  const max_gas_ = parseInt(max_gas);
  const payload =
    Coin_list.Coin_list.buildPayload_add_approver_to_registry(approver_);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:add-approver-to-registry")
  .description("")
  .argument("<approver>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_add_approver_to_registry);

const coin_list_add_extension = async (
  CoinType: string,
  key: string,
  value: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const key_ = new ActualStringClass(
    { bytes: strToU8(key) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const value_ = new ActualStringClass(
    { bytes: strToU8(value) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_extension(key_, value_, [
    CoinType_,
  ]);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:add-extension")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<key>")
  .argument("<value>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_add_extension);

const coin_list_add_to_list = async (
  CoinType: string,
  list: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const list_ = new HexString(list);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_to_list(list_, [
    CoinType_,
  ]);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:add-to-list")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<list>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_add_to_list);

const coin_list_add_to_registry_by_approver = async (
  CoinType: string,
  name: string,
  symbol: string,
  coingecko_id: string,
  logo_url: string,
  project_url: string,
  is_update: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const name_ = new ActualStringClass(
    { bytes: strToU8(name) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const symbol_ = new ActualStringClass(
    { bytes: strToU8(symbol) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const coingecko_id_ = new ActualStringClass(
    { bytes: strToU8(coingecko_id) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const logo_url_ = new ActualStringClass(
    { bytes: strToU8(logo_url) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const project_url_ = new ActualStringClass(
    { bytes: strToU8(project_url) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const is_update_ = is_update == "true";
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_to_registry_by_approver(
    name_,
    symbol_,
    coingecko_id_,
    logo_url_,
    project_url_,
    is_update_,
    [CoinType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:add-to-registry-by-approver")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<name>")
  .argument("<symbol>")
  .argument("<coingecko_id>")
  .argument("<logo_url>")
  .argument("<project_url>")
  .argument("<is_update>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_add_to_registry_by_approver);

const coin_list_add_to_registry_by_signer = async (
  CoinType: string,
  name: string,
  symbol: string,
  coingecko_id: string,
  logo_url: string,
  project_url: string,
  is_update: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const name_ = new ActualStringClass(
    { bytes: strToU8(name) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const symbol_ = new ActualStringClass(
    { bytes: strToU8(symbol) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const coingecko_id_ = new ActualStringClass(
    { bytes: strToU8(coingecko_id) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const logo_url_ = new ActualStringClass(
    { bytes: strToU8(logo_url) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const project_url_ = new ActualStringClass(
    { bytes: strToU8(project_url) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const is_update_ = is_update == "true";
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_add_to_registry_by_signer(
    name_,
    symbol_,
    coingecko_id_,
    logo_url_,
    project_url_,
    is_update_,
    [CoinType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:add-to-registry-by-signer")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<name>")
  .argument("<symbol>")
  .argument("<coingecko_id>")
  .argument("<logo_url>")
  .argument("<project_url>")
  .argument("<is_update>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_add_to_registry_by_signer);

const coin_list_create_list = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_create_list();
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:create-list")
  .description("")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_create_list);

const coin_list_drop_extension = async (
  CoinType: string,
  key: string,
  value: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const key_ = new ActualStringClass(
    { bytes: strToU8(key) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const value_ = new ActualStringClass(
    { bytes: strToU8(value) },
    parseTypeTagOrThrow("0x1::string::String")
  );
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_drop_extension(
    key_,
    value_,
    [CoinType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:drop-extension")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<key>")
  .argument("<value>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_drop_extension);

const coin_list_initialize = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_initialize();
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:initialize")
  .description("")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_initialize);

const coin_list_remove_approver_from_list = async (
  approver: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const approver_ = new HexString(approver);
  const max_gas_ = parseInt(max_gas);
  const payload =
    Coin_list.Coin_list.buildPayload_remove_approver_from_list(approver_);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:remove-approver-from-list")
  .description("")
  .argument("<approver>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_remove_approver_from_list);

const coin_list_remove_approver_from_registry = async (
  approver: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const approver_ = new HexString(approver);
  const max_gas_ = parseInt(max_gas);
  const payload =
    Coin_list.Coin_list.buildPayload_remove_approver_from_registry(approver_);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:remove-approver-from-registry")
  .description("")
  .argument("<approver>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_remove_approver_from_registry);

const coin_list_remove_from_list = async (
  CoinType: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Coin_list.buildPayload_remove_from_list([
    CoinType_,
  ]);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:remove-from-list")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_remove_from_list);

const coin_list_remove_from_registry_by_approver = async (
  CoinType: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const max_gas_ = parseInt(max_gas);
  const payload =
    Coin_list.Coin_list.buildPayload_remove_from_registry_by_approver([
      CoinType_,
    ]);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:remove-from-registry-by-approver")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_remove_from_registry_by_approver);

const coin_list_remove_from_registry_by_signer = async (
  CoinType: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const max_gas_ = parseInt(max_gas);
  const payload =
    Coin_list.Coin_list.buildPayload_remove_from_registry_by_signer([
      CoinType_,
    ]);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("coin-list:remove-from-registry-by-signer")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_remove_from_registry_by_signer);

const devnet_coins_mint_to_wallet = async (
  CoinType: string,
  amount: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const amount_ = u64(amount);
  const max_gas_ = parseInt(max_gas);
  const payload = Coin_list.Devnet_coins.buildPayload_mint_to_wallet(amount_, [
    CoinType_,
  ]);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("devnet-coins:mint-to-wallet")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<amount>")
  .argument("[max_gas]", "", "10000")
  .action(devnet_coins_mint_to_wallet);

const assets_init_coin_types = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Assets.buildPayload_init_coin_types();
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("assets:init-coin-types")
  .description("")
  .argument("[max_gas]", "", "10000")
  .action(assets_init_coin_types);

const assets_mint = async (
  CoinType: string,
  amount: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const amount_ = u64(amount);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Assets.buildPayload_mint(amount_, [CoinType_]);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("assets:mint")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<amount>")
  .argument("[max_gas]", "", "10000")
  .action(assets_mint);

const market_cancel_all_limit_orders_user = async (
  host: string,
  market_id: string,
  side: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const side_ = side == "true";
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_cancel_all_limit_orders_user(
    host_,
    market_id_,
    side_
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("market:cancel-all-limit-orders-user")
  .description("")
  .argument("<host>")
  .argument("<market_id>")
  .argument("<side>")
  .argument("[max_gas]", "", "10000")
  .action(market_cancel_all_limit_orders_user);

const market_cancel_limit_order_user = async (
  host: string,
  market_id: string,
  side: string,
  order_id: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const side_ = side == "true";
  const order_id_ = u128(order_id);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_cancel_limit_order_user(
    host_,
    market_id_,
    side_,
    order_id_
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("market:cancel-limit-order-user")
  .description("")
  .argument("<host>")
  .argument("<market_id>")
  .argument("<side>")
  .argument("<order_id>")
  .argument("[max_gas]", "", "10000")
  .action(market_cancel_limit_order_user);

const market_place_limit_order_user = async (
  BaseType: string,
  QuoteType: string,
  host: string,
  market_id: string,
  side: string,
  size: string,
  price: string,
  post_or_abort: string,
  fill_or_abort: string,
  immediate_or_cancel: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const BaseType_ = parseTypeTagOrThrow(BaseType);
  const QuoteType_ = parseTypeTagOrThrow(QuoteType);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const side_ = side == "true";
  const size_ = u64(size);
  const price_ = u64(price);
  const post_or_abort_ = post_or_abort == "true";
  const fill_or_abort_ = fill_or_abort == "true";
  const immediate_or_cancel_ = immediate_or_cancel == "true";
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_place_limit_order_user(
    host_,
    market_id_,
    side_,
    size_,
    price_,
    post_or_abort_,
    fill_or_abort_,
    immediate_or_cancel_,
    [BaseType_, QuoteType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("market:place-limit-order-user")
  .description("")
  .argument("<TYPE_BaseType>")
  .argument("<TYPE_QuoteType>")
  .argument("<host>")
  .argument("<market_id>")
  .argument("<side>")
  .argument("<size>")
  .argument("<price>")
  .argument("<post_or_abort>")
  .argument("<fill_or_abort>")
  .argument("<immediate_or_cancel>")
  .argument("[max_gas]", "", "10000")
  .action(market_place_limit_order_user);

const market_place_market_order_user = async (
  BaseType: string,
  QuoteType: string,
  host: string,
  market_id: string,
  direction: string,
  min_base: string,
  max_base: string,
  min_quote: string,
  max_quote: string,
  limit_price: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const BaseType_ = parseTypeTagOrThrow(BaseType);
  const QuoteType_ = parseTypeTagOrThrow(QuoteType);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const direction_ = direction == "true";
  const min_base_ = u64(min_base);
  const max_base_ = u64(max_base);
  const min_quote_ = u64(min_quote);
  const max_quote_ = u64(max_quote);
  const limit_price_ = u64(limit_price);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_place_market_order_user(
    host_,
    market_id_,
    direction_,
    min_base_,
    max_base_,
    min_quote_,
    max_quote_,
    limit_price_,
    [BaseType_, QuoteType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("market:place-market-order-user")
  .description("")
  .argument("<TYPE_BaseType>")
  .argument("<TYPE_QuoteType>")
  .argument("<host>")
  .argument("<market_id>")
  .argument("<direction>")
  .argument("<min_base>")
  .argument("<max_base>")
  .argument("<min_quote>")
  .argument("<max_quote>")
  .argument("<limit_price>")
  .argument("[max_gas]", "", "10000")
  .action(market_place_market_order_user);

const market_register_market_pure_coin = async (
  BaseCoinType: string,
  QuoteCoinType: string,
  lot_size: string,
  tick_size: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const BaseCoinType_ = parseTypeTagOrThrow(BaseCoinType);
  const QuoteCoinType_ = parseTypeTagOrThrow(QuoteCoinType);
  const lot_size_ = u64(lot_size);
  const tick_size_ = u64(tick_size);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_register_market_pure_coin(
    lot_size_,
    tick_size_,
    [BaseCoinType_, QuoteCoinType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("market:register-market-pure-coin")
  .description("")
  .argument("<TYPE_BaseCoinType>")
  .argument("<TYPE_QuoteCoinType>")
  .argument("<lot_size>")
  .argument("<tick_size>")
  .argument("[max_gas]", "", "10000")
  .action(market_register_market_pure_coin);

const market_swap_between_coinstores = async (
  BaseCoinType: string,
  QuoteCoinType: string,
  host: string,
  market_id: string,
  direction: string,
  min_base: string,
  max_base: string,
  min_quote: string,
  max_quote: string,
  limit_price: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const BaseCoinType_ = parseTypeTagOrThrow(BaseCoinType);
  const QuoteCoinType_ = parseTypeTagOrThrow(QuoteCoinType);
  const host_ = new HexString(host);
  const market_id_ = u64(market_id);
  const direction_ = direction == "true";
  const min_base_ = u64(min_base);
  const max_base_ = u64(max_base);
  const min_quote_ = u64(min_quote);
  const max_quote_ = u64(max_quote);
  const limit_price_ = u64(limit_price);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Market.buildPayload_swap_between_coinstores(
    host_,
    market_id_,
    direction_,
    min_base_,
    max_base_,
    min_quote_,
    max_quote_,
    limit_price_,
    [BaseCoinType_, QuoteCoinType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("market:swap-between-coinstores")
  .description("")
  .argument("<TYPE_BaseCoinType>")
  .argument("<TYPE_QuoteCoinType>")
  .argument("<host>")
  .argument("<market_id>")
  .argument("<direction>")
  .argument("<min_base>")
  .argument("<max_base>")
  .argument("<min_quote>")
  .argument("<max_quote>")
  .argument("<limit_price>")
  .argument("[max_gas]", "", "10000")
  .action(market_swap_between_coinstores);

const registry_init_registry = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.Registry.buildPayload_init_registry();
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("registry:init-registry")
  .description("")
  .argument("[max_gas]", "", "10000")
  .action(registry_init_registry);

const user_deposit_from_coinstore = async (
  CoinType: string,
  market_id: string,
  general_custodian_id: string,
  amount: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const market_id_ = u64(market_id);
  const general_custodian_id_ = u64(general_custodian_id);
  const amount_ = u64(amount);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.User.buildPayload_deposit_from_coinstore(
    market_id_,
    general_custodian_id_,
    amount_,
    [CoinType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("user:deposit-from-coinstore")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<market_id>")
  .argument("<general_custodian_id>")
  .argument("<amount>")
  .argument("[max_gas]", "", "10000")
  .action(user_deposit_from_coinstore);

const user_register_market_account = async (
  BaseType: string,
  QuoteType: string,
  market_id: string,
  general_custodian_id: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const BaseType_ = parseTypeTagOrThrow(BaseType);
  const QuoteType_ = parseTypeTagOrThrow(QuoteType);
  const market_id_ = u64(market_id);
  const general_custodian_id_ = u64(general_custodian_id);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.User.buildPayload_register_market_account(
    market_id_,
    general_custodian_id_,
    [BaseType_, QuoteType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("user:register-market-account")
  .description("")
  .argument("<TYPE_BaseType>")
  .argument("<TYPE_QuoteType>")
  .argument("<market_id>")
  .argument("<general_custodian_id>")
  .argument("[max_gas]", "", "10000")
  .action(user_register_market_account);

const user_withdraw_to_coinstore = async (
  CoinType: string,
  market_id: string,
  amount: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const CoinType_ = parseTypeTagOrThrow(CoinType);
  const market_id_ = u64(market_id);
  const amount_ = u64(amount);
  const max_gas_ = parseInt(max_gas);
  const payload = Econia.User.buildPayload_withdraw_to_coinstore(
    market_id_,
    amount_,
    [CoinType_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("user:withdraw-to-coinstore")
  .description("")
  .argument("<TYPE_CoinType>")
  .argument("<market_id>")
  .argument("<amount>")
  .argument("[max_gas]", "", "10000")
  .action(user_withdraw_to_coinstore);

const aggregator_init_coin_store = async (X: string, max_gas: string) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_init_coin_store([
    X_,
  ]);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("aggregator:init-coin-store")
  .description("")
  .argument("<TYPE_X>")
  .argument("[max_gas]", "", "10000")
  .action(aggregator_init_coin_store);

const aggregator_init_coin_store_all = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload =
    Hippo_aggregator.Aggregator.buildPayload_init_coin_store_all();
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("aggregator:init-coin-store-all")
  .description("")
  .argument("[max_gas]", "", "10000")
  .action(aggregator_init_coin_store_all);

const aggregator_one_step_route = async (
  X: string,
  Y: string,
  E: string,
  first_dex_type: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  x_in: string,
  y_min_out: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const E_ = parseTypeTagOrThrow(E);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const y_min_out_ = u64(y_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_one_step_route(
    first_dex_type_,
    first_pool_type_,
    first_is_x_to_y_,
    x_in_,
    y_min_out_,
    [X_, Y_, E_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("aggregator:one-step-route")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_E>")
  .argument("<first_dex_type>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<x_in>")
  .argument("<y_min_out>")
  .argument("[max_gas]", "", "10000")
  .action(aggregator_one_step_route);

const aggregator_swap = async (
  X: string,
  Y: string,
  Z: string,
  OutCoin: string,
  E1: string,
  E2: string,
  E3: string,
  num_steps: string,
  first_dex_type: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  second_dex_type: string,
  second_pool_type: string,
  second_is_x_to_y: string,
  third_dex_type: string,
  third_pool_type: string,
  third_is_x_to_y: string,
  x_in: string,
  m_min_out: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const OutCoin_ = parseTypeTagOrThrow(OutCoin);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const num_steps_ = u8(num_steps);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u64(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y == "true";
  const third_dex_type_ = u8(third_dex_type);
  const third_pool_type_ = u64(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const m_min_out_ = u64(m_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_swap(
    num_steps_,
    first_dex_type_,
    first_pool_type_,
    first_is_x_to_y_,
    second_dex_type_,
    second_pool_type_,
    second_is_x_to_y_,
    third_dex_type_,
    third_pool_type_,
    third_is_x_to_y_,
    x_in_,
    m_min_out_,
    [X_, Y_, Z_, OutCoin_, E1_, E2_, E3_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("aggregator:swap")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_Z>")
  .argument("<TYPE_OutCoin>")
  .argument("<TYPE_E1>")
  .argument("<TYPE_E2>")
  .argument("<TYPE_E3>")
  .argument("<num_steps>")
  .argument("<first_dex_type>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<second_dex_type>")
  .argument("<second_pool_type>")
  .argument("<second_is_x_to_y>")
  .argument("<third_dex_type>")
  .argument("<third_pool_type>")
  .argument("<third_is_x_to_y>")
  .argument("<x_in>")
  .argument("<m_min_out>")
  .argument("[max_gas]", "", "10000")
  .action(aggregator_swap);

const aggregator_three_step_route = async (
  X: string,
  Y: string,
  Z: string,
  M: string,
  E1: string,
  E2: string,
  E3: string,
  first_dex_type: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  second_dex_type: string,
  second_pool_type: string,
  second_is_x_to_y: string,
  third_dex_type: string,
  third_pool_type: string,
  third_is_x_to_y: string,
  x_in: string,
  m_min_out: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const M_ = parseTypeTagOrThrow(M);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u64(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y == "true";
  const third_dex_type_ = u8(third_dex_type);
  const third_pool_type_ = u64(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const m_min_out_ = u64(m_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_three_step_route(
    first_dex_type_,
    first_pool_type_,
    first_is_x_to_y_,
    second_dex_type_,
    second_pool_type_,
    second_is_x_to_y_,
    third_dex_type_,
    third_pool_type_,
    third_is_x_to_y_,
    x_in_,
    m_min_out_,
    [X_, Y_, Z_, M_, E1_, E2_, E3_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("aggregator:three-step-route")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_Z>")
  .argument("<TYPE_M>")
  .argument("<TYPE_E1>")
  .argument("<TYPE_E2>")
  .argument("<TYPE_E3>")
  .argument("<first_dex_type>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<second_dex_type>")
  .argument("<second_pool_type>")
  .argument("<second_is_x_to_y>")
  .argument("<third_dex_type>")
  .argument("<third_pool_type>")
  .argument("<third_is_x_to_y>")
  .argument("<x_in>")
  .argument("<m_min_out>")
  .argument("[max_gas]", "", "10000")
  .action(aggregator_three_step_route);

const aggregator_two_step_route = async (
  X: string,
  Y: string,
  Z: string,
  E1: string,
  E2: string,
  first_dex_type: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  second_dex_type: string,
  second_pool_type: string,
  second_is_x_to_y: string,
  x_in: string,
  z_min_out: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u64(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const z_min_out_ = u64(z_min_out);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Aggregator.buildPayload_two_step_route(
    first_dex_type_,
    first_pool_type_,
    first_is_x_to_y_,
    second_dex_type_,
    second_pool_type_,
    second_is_x_to_y_,
    x_in_,
    z_min_out_,
    [X_, Y_, Z_, E1_, E2_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("aggregator:two-step-route")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_Z>")
  .argument("<TYPE_E1>")
  .argument("<TYPE_E2>")
  .argument("<first_dex_type>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<second_dex_type>")
  .argument("<second_pool_type>")
  .argument("<second_is_x_to_y>")
  .argument("<x_in>")
  .argument("<z_min_out>")
  .argument("[max_gas]", "", "10000")
  .action(aggregator_two_step_route);

const devnet_mock_deploy_basiq = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Devnet.buildPayload_mock_deploy_basiq();
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("devnet:mock-deploy-basiq")
  .description("Create BTC-USDC pool on econia and add liquidity")
  .argument("[max_gas]", "", "10000")
  .action(devnet_mock_deploy_basiq);

const devnet_mock_deploy_econia = async (
  market_id: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const market_id_ = u64(market_id);
  const max_gas_ = parseInt(max_gas);
  const payload =
    Hippo_aggregator.Devnet.buildPayload_mock_deploy_econia(market_id_);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("devnet:mock-deploy-econia")
  .description("Create BTC-USDC pool on econia and add liquidity")
  .argument("<market_id>")
  .argument("[max_gas]", "", "10000")
  .action(devnet_mock_deploy_econia);

const devnet_mock_deploy_pontem = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Devnet.buildPayload_mock_deploy_pontem();
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("devnet:mock-deploy-pontem")
  .description("Create BTC-USDC pool on pontem and add liquidity")
  .argument("[max_gas]", "", "10000")
  .action(devnet_mock_deploy_pontem);

const volume_clean = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Volume.buildPayload_clean();
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("volume:clean")
  .description("")
  .argument("[max_gas]", "", "10000")
  .action(volume_clean);

const volume_initialize = async (poster: string, max_gas: string) => {
  const { client, account } = readConfig(program);
  const poster_ = new HexString(poster);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Volume.buildPayload_initialize(poster_);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("volume:initialize")
  .description("")
  .argument("<poster>")
  .argument("[max_gas]", "", "10000")
  .action(volume_initialize);

const volume_set_poster = async (new_poster: string, max_gas: string) => {
  const { client, account } = readConfig(program);
  const new_poster_ = new HexString(new_poster);
  const max_gas_ = parseInt(max_gas);
  const payload = Hippo_aggregator.Volume.buildPayload_set_poster(new_poster_);
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("volume:set-poster")
  .description("")
  .argument("<new_poster>")
  .argument("[max_gas]", "", "10000")
  .action(volume_set_poster);

const sample_swap_and_transfer = async (
  X: string,
  Y: string,
  Z: string,
  OutCoin: string,
  E1: string,
  E2: string,
  E3: string,
  num_steps: string,
  first_dex_type: string,
  first_pool_type: string,
  first_is_x_to_y: string,
  second_dex_type: string,
  second_pool_type: string,
  second_is_x_to_y: string,
  third_dex_type: string,
  third_pool_type: string,
  third_is_x_to_y: string,
  x_in: string,
  target_address: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const X_ = parseTypeTagOrThrow(X);
  const Y_ = parseTypeTagOrThrow(Y);
  const Z_ = parseTypeTagOrThrow(Z);
  const OutCoin_ = parseTypeTagOrThrow(OutCoin);
  const E1_ = parseTypeTagOrThrow(E1);
  const E2_ = parseTypeTagOrThrow(E2);
  const E3_ = parseTypeTagOrThrow(E3);
  const num_steps_ = u8(num_steps);
  const first_dex_type_ = u8(first_dex_type);
  const first_pool_type_ = u64(first_pool_type);
  const first_is_x_to_y_ = first_is_x_to_y == "true";
  const second_dex_type_ = u8(second_dex_type);
  const second_pool_type_ = u64(second_pool_type);
  const second_is_x_to_y_ = second_is_x_to_y == "true";
  const third_dex_type_ = u8(third_dex_type);
  const third_pool_type_ = u64(third_pool_type);
  const third_is_x_to_y_ = third_is_x_to_y == "true";
  const x_in_ = u64(x_in);
  const target_address_ = new HexString(target_address);
  const max_gas_ = parseInt(max_gas);
  const payload = Sample.Sample.buildPayload_swap_and_transfer(
    num_steps_,
    first_dex_type_,
    first_pool_type_,
    first_is_x_to_y_,
    second_dex_type_,
    second_pool_type_,
    second_is_x_to_y_,
    third_dex_type_,
    third_pool_type_,
    third_is_x_to_y_,
    x_in_,
    target_address_,
    [X_, Y_, Z_, OutCoin_, E1_, E2_, E3_]
  );
  await sendPayloadTxAndLog(client, account, payload, {
    maxGasAmount: max_gas_,
  });
};

program
  .command("sample:swap-and-transfer")
  .description("")
  .argument("<TYPE_X>")
  .argument("<TYPE_Y>")
  .argument("<TYPE_Z>")
  .argument("<TYPE_OutCoin>")
  .argument("<TYPE_E1>")
  .argument("<TYPE_E2>")
  .argument("<TYPE_E3>")
  .argument("<num_steps>")
  .argument("<first_dex_type>")
  .argument("<first_pool_type>")
  .argument("<first_is_x_to_y>")
  .argument("<second_dex_type>")
  .argument("<second_pool_type>")
  .argument("<second_is_x_to_y>")
  .argument("<third_dex_type>")
  .argument("<third_pool_type>")
  .argument("<third_is_x_to_y>")
  .argument("<x_in>")
  .argument("<target_address>")
  .argument("[max_gas]", "", "10000")
  .action(sample_swap_and_transfer);

const coin_list_fetch_all_registered_coin_info = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const repo = getProjectRepo();
  const value = await Coin_list.Coin_list.query_fetch_all_registered_coin_info(
    client,
    getSimulationKeys(account),
    repo,
    [],
    { maxGasAmount: parseInt(max_gas) }
  );
  print(value);
};

program
  .command("coin-list:query-fetch-all-registered-coin-info")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_fetch_all_registered_coin_info);

const coin_list_fetch_full_list = async (
  list_owner_addr: string,
  max_gas: string
) => {
  const { client, account } = readConfig(program);
  const repo = getProjectRepo();
  const value = await Coin_list.Coin_list.query_fetch_full_list(
    client,
    getSimulationKeys(account),
    repo,
    new HexString(list_owner_addr),
    [],
    { maxGasAmount: parseInt(max_gas) }
  );
  print(value);
};

program
  .command("coin-list:query-fetch-full-list")
  .argument("<list_owner_addr>")
  .argument("[max_gas]", "", "10000")
  .action(coin_list_fetch_full_list);

const volume_fetch_volume = async (max_gas: string) => {
  const { client, account } = readConfig(program);
  const repo = getProjectRepo();
  const value = await Hippo_aggregator.Volume.query_fetch_volume(
    client,
    getSimulationKeys(account),
    repo,
    [],
    { maxGasAmount: parseInt(max_gas) }
  );
  print(value);
};

program
  .command("volume:query-fetch-volume")
  .argument("[max_gas]", "", "10000")
  .action(volume_fetch_volume);

const testSwap = async (
  symbolX: string,
  symbolY: string,
  xInAmt: string,
  targetAddress: string
) => {
  const { client, account } = readConfig(program);
  const agg = await TradeAggregator.create(client);
  const xInfo = agg.coinListClient.getCoinInfoBySymbol(symbolX)[0];
  const yInfo = agg.coinListClient.getCoinInfoBySymbol(symbolY)[0];
  const quote = await agg.getBestQuote(parseFloat(xInAmt), xInfo, yInfo);
  if (!quote) {
    console.log(`No quote from ${symbolX} to ${symbolY}`);
    return;
  }
  const params = quote.route.getSwapParams(parseFloat(xInAmt), 0);
  const payload = buildPayload_swap_and_transfer(
    params.numSteps,
    params.firstDexType,
    params.firstPoolType,
    params.firstIsReversed,
    params.secondDexType,
    params.secondPoolType,
    params.secondIsReversed,
    params.thirdDexType,
    params.thirdPoolType,
    params.thirdIsReversed,
    params.inAmt,
    new HexString(targetAddress),
    params.types
  );

  await sendPayloadTxAndLog(client, account, payload);
};

program
  .command("test-swap")
  .argument("symbolX")
  .argument("symbolY")
  .argument("xInAmt")
  .argument("targetAddress")
  .action(testSwap);

const testSwapLocal = async (
  symbolX: string,
  symbolY: string,
  xInAmt: string,
  targetAddress: string
) => {
  const { client, account } = readConfig(program);
  const agg = new TradeAggregator(client);
  console.log("Loading coin list...");
  await agg.coinListClient.update(client);
  const xInfo = agg.coinListClient.getCoinInfoBySymbol(symbolX)[0];
  const yInfo = agg.coinListClient.getCoinInfoBySymbol(symbolY)[0];
  const inputAmt = parseFloat(xInAmt);
  console.log("Loading quotes...");
  const quotes = await agg.getQuotes(inputAmt, xInfo, yInfo);
  if (quotes.length === 0) {
    console.log(`No quote from ${symbolX} to ${symbolY}`);
    return;
  }

  const routeSelected = quotes[0];
  const params = routeSelected.route.getSwapParams(inputAmt, 0);
  const payload = buildPayload_swap_and_transfer(
    params.numSteps,
    params.firstDexType,
    params.firstPoolType,
    params.firstIsReversed,
    params.secondDexType,
    params.secondPoolType,
    params.secondIsReversed,
    params.thirdDexType,
    params.thirdPoolType,
    params.thirdIsReversed,
    params.inAmt,
    new HexString(targetAddress),
    params.types
  );

  console.log("Sending tx...");
  await sendPayloadTxAndLog(client, account, payload);
};

program
  .command("test-swap-local")
  .argument("symbolX")
  .argument("symbolY")
  .argument("xInAmt")
  .argument("targetAddress")
  .action(testSwapLocal);

const testSwapApi = async (
  symbolX: string,
  symbolY: string,
  xInAmt: string,
  targetAddress: string
) => {
  const { client, account } = readConfig(program);
  const agg = new TradeAggregator(client);
  console.log("Loading coin list...");
  await agg.coinListClient.update(client);
  const xInfo = agg.coinListClient.getCoinInfoBySymbol(symbolX)[0];
  const yInfo = agg.coinListClient.getCoinInfoBySymbol(symbolY)[0];
  const inputAmt = parseFloat(xInAmt);
  const isReload = true;
  console.log("Fetching quotes...");
  const result = await agg.requestQuotesViaAPI(
    inputAmt,
    xInfo,
    yInfo,
    isReload
  );
  if (result.allRoutesCount === 0) {
    console.log(`No quote from ${symbolX} to ${symbolY}`);
    return;
  }
  console.log(`Fetched ${result.allRoutesCount} quotes`);

  const routeSelected = result.routes[0];
  const params = routeSelected.route.getSwapParams(inputAmt, 0);
  const payload = buildPayload_swap_and_transfer(
    params.numSteps,
    params.firstDexType,
    params.firstPoolType,
    params.firstIsReversed,
    params.secondDexType,
    params.secondPoolType,
    params.secondIsReversed,
    params.thirdDexType,
    params.thirdPoolType,
    params.thirdIsReversed,
    params.inAmt,
    new HexString(targetAddress),
    params.types
  );

  console.log("Sending tx...");
  await sendPayloadTxAndLog(client, account, payload);
};

program
  .command("test-swap-api")
  .argument("symbolX")
  .argument("symbolY")
  .argument("xInAmt")
  .argument("targetAddress")
  .action(testSwapApi);

program.parse();
